#클로저에 대해서.

————————————————
###클로저란, 외부함수가 완전히 실행된 이후 콜스택에서 빠져나와도 내부함수가 그 외부함수에서
선언된 지역변수를 접근가능한 것을 클로저라고 한다.(외부함수에 선언된 지역변수를 복사하는 것이 아니라 외부함수에 선언된 지역변수를 참조하는 것)

###ex) 예시(예시문 참조는 poiemaweb.com)
——————————————
```
var arr = [];                   //[1]

for(var i = 0; i < 5; i++){
  arr[i] = function(){
    return i;
  }
}                               //[2]

for(var index in arr) {
  console.log(arr[index]());    //[3]
}
```
——————————————
위의 코드를 살펴보면,[1]번에서 arr에 빈 array를 할당한다.[2]번에서는 arr의 각 index마다 function(){return i;}라는 함수를 할당한다.즉, 이터레이션을 다 돌고 난 후에는 arr의 모습은,
```
arr = [function(){return i},
	function(){return i},
	function(){return i},
	function(){return i},
	function(){return i}]
```
위와 같으며, 이터레이션이 완벽히 다 돌고 난 후이기에 i값은 5가 된다.
그리고 [3]번에서 각 arr의 index마다 할당된 함수를 실행 하는데, 이미 이터레이션을 완벽히 다 돌고 난 후인 i값을 return 함으로, 5가 5번 출력되는것이다.

위 코드의 의도는 arr의 인덱스마다 각각의 인덱스값을 출력하는게 목적이므로, 위 문제를 해결하기 위한 방법중 하나가 바로 클로저이다.
———————————————————
```
var arr = [] //————————————————[1]

for(var i = 0; i < 5; i++){
  arr[i] = function(id) {     //[2] 
    return function(){        //[내부함수] 
      return id;
    }
  }(i); //—————————————————————[3]
}

for(var index in arr) {
  console.log(arr[index]());  //[4]
}
```
———————————————
위의 코드 [2]번의 함수를 자세히보면 즉시 실행 함수인 것을 알 수 있다.

즉 [3]번에 for문이 이터레이션을 돌면서 동시에 [2]번의 함수를 즉시 실행 시키는 것이다.

[2]번의 함수의 파라미터인 id에 i가 실시간으로 인자값으로 전해지면서 [2]번 함수 내부에서는 실질적으로 var id = i인 지역변수가 이터레이션을 돌때마다 형성이 되는것이다.

(i = 0일때 var id = 0이라는 지역변수가,i = 1일때 var id = 1이라는 지역변수가…)

또 그렇게 지역변수로 id값이 할당이 되었지만 즉시 실행 함수이기에 실시간으로 함수가 실행된후 콜스택에서 빠져나가 id라는 지역변수도 없어져야되지만 

[2]번 함수안에 있는 [내부함수]가 id값을 참조해야되므로, arr인덱스 마다 할당된 각각의 내부함수들은 그 내부함수의 외부함수인, [2]번함수안에 각각 선언된 지역변수를 참조하기 때문에 [4]번을 통해 arr의 인덱스마다 할당된 함수를 호출하면 그에 따른 i값이 출력되는 것이다. 


edited by websotrm.









